# TCP

### 一.TCP的目的

在多跳级联的有损信道中，实现可靠的合理的信息传输

### 二.核心问题

**如何处理信息丢失或比特差错？**

* 差错纠正码（添加冗余比特），WebRTC的FEC选择的方式
* 重传，TCP选择的方式

### 三.重传的可靠性挑战

**发送方如何确定接收方已经接收到分组？**

* 接收方发送ack给发送方，`发送方发一个分组，等待一个ack`

这会引入3个新问题

* 问题1：发送方应该为ack等待多长时间？
* 问题2：发送方没有收到ack怎么办？
* 问题3：分组接收到了，但是有错怎么办？

### 1.问题1

要等待多久才能判定一个分组丢失并将其重发？判定方法是通过协议进行估计，即`往返时间估计`

### 2.问题2

在这种情况下，对于发送方来说，有两种可能：

* 原分组丢失
* ack丢失

不论哪种情况，发送方都需要再次发送原分组。这就引入了一个新问题，`接收方收到两个相同的分组怎么办？`，解决方法是使用`序列号`，分组本身带着序列号，如果接收方见过则丢弃它

### 3.问题3

使用CRC校验，检测到错误直接丢弃

### 四.重传的效率挑战

**发送一个包，等待一个ack，很明显效率不高，如何提高效率？**

* 同时发送多个分组到网络中

这将引入4个新问题

* 问题1：发送方要决定发送多少个分组到网络中，发送方在等待ack时，如何维护计时器，同时还要保存未被确认的副本以防止重传
* 问题2：接收方需要更复杂的ack机制，区分哪些分组已经收到，哪些还没有，并且接收方收到的分组会出现次序杂乱的情况，这对缓存分组的机制提出了挑战
* 问题3：发送方速率比接收方快怎么办？
* 问题4：中间的网络链路承受不了发送方和接受方使用的数据发送速率怎么办？

### 1.问题1和2

使用滑动窗口协议来解决，比如发送方`窗口(window)`是指被发送方注入到网络中，但是还没被确认的分组集合，窗口的分组数量就是`窗口大小(window size)`&#x20;

<figure><img src="../../.gitbook/assets/image (27).png" alt=""><figcaption></figcaption></figure>

接收窗口如下

<figure><img src="../../.gitbook/assets/image (1) (1).png" alt=""><figcaption></figcaption></figure>

### 2.问题3

`流量控制`，有两种方法

* 基于速率的流量控制，给发送方指定速率，不可以超过这个速率
* 基于窗口的流量控制，使用滑动窗口进行控制，窗口是可以动态变化的，必须有一种方法让接收方可以通知发送方使用多大的窗口，这叫做`窗口通告`或者`窗口更新`

### 3.问题4

`拥塞控制`，当发送方的速率超过中间某个路由器的能力，导致丢包，这种情况下同样需要降低发送方速率，拥塞控制有多种算法，如cubic、new reno、bbr等

**流量控制和拥塞控制的异同？**

* 流量控制解决的问题是发送方和接受方速率不匹配的问题，拥塞控制解决的是发送方和中间链路速率不匹配的问题
* 流量控制是接收方来控制发送方窗口减小，拥塞控制是发送方自己探测到丢包，从而自己减小自己的窗口大小
* 流量控制和拥塞控制都是减少发送方的窗口大小

### 五.协议设计

### 1.协议字段

<figure><img src="../../.gitbook/assets/image (2) (1).png" alt=""><figcaption></figcaption></figure>

| 字段   | 大小    | 描述                                                                               |
| ---- | ----- | -------------------------------------------------------------------------------- |
| 序列号  | 32bit | 发送方的数据中第一个字节偏移，最开始的序列号是随机取的值。note：`SYN、FIN和数据字节是消耗序列号的，所以被可靠传输，ACK不消耗序列号，不被可靠传输` |
| 确认号  | 32bit | 接收方成功`顺序`接收的数据中最后一个字节偏移加1                                                        |
| ACK  | 1bit  | 标识确认号是否有效                                                                        |
| 窗口大小 | 16bit | 从接收方发出的确认号开始，接收方想要接收多少数据，用于流量控制                                                  |
| 头部长度 | 4bit  | 以4字节为单位，说明tcp头部最大值为60字节                                                          |
| 选项   | 可变    | tcp附加能力的选项                                                                       |

**tcp选项如下**

<figure><img src="../../.gitbook/assets/image (3) (1).png" alt=""><figcaption></figcaption></figure>

### 2.TSOPT

时间戳选项默认启用

<figure><img src="../../.gitbook/assets/image (5) (1).png" alt=""><figcaption></figcaption></figure>

推荐layout(TCP头部必须是4字节的倍数)&#x20;

<figure><img src="../../.gitbook/assets/image (6) (1).png" alt=""><figcaption></figcaption></figure>

### 3.SACK

sack选项指定n个块需要8n+2个字节，和TSOPT配合时，40字节的TCP选项可以有一个TSOPT和包含3个块的SACK，说明`一个RTT的时间内sack可以填补3个空缺`&#x20;

<figure><img src="../../.gitbook/assets/image (7) (1).png" alt=""><figcaption></figcaption></figure>

### 4.SACK-Permitted

表明发送端支持sack，这个选项不能出现在非SYN报文中

<figure><img src="../../.gitbook/assets/image (8) (1).png" alt=""><figcaption></figcaption></figure>

### 5.窗口缩放

窗口大小只有16位，限制了最大只能为65535，从而限制了tcp的吞吐量，可以通过窗口缩放选项来对该值进行缩放，从而为高速和大延迟网络改善了性能

### 六.重传的判定

重传有两种判定方法

* tcp在发送数据的时候设置计时器，如果超时且没收到ack，计时器超时称为重传超时(RTO)
* 如果收到多个相同的ack，或者sack里表明有失序报文段，进行重传

### 1.超时重传

如何根据RTT估算RTO是一个复杂的问题，RTO对TCP的性能至关重要

#### **1.1 设置RTO的标准方法**

<figure><img src="../../.gitbook/assets/image (9) (1).png" alt=""><figcaption></figcaption></figure>

* M为RTT测量值，srtt为M的指数加权移动平均，即Exponentially Weighted Moving Average(EWMA)，g取1/8
* rttvar为偏差估计值，同样是EWMA，h取1/4
* `linux中的实现与其有些许不同`，其作者在280万个流多个系统中运行RTT估算算法，结果表明linux估计器性能最优

#### **1.2 RFC6298**

RFC6298中提出一个新的公式

<figure><img src="../../.gitbook/assets/image (10) (1).png" alt=""><figcaption></figcaption></figure>

* G为操作系统计时器粒度，RTO至少为1s
* 根据RFC6298，`RTO初始值为1s，初始SYN报文段采用的超时时间为3s，当接收到首个RTT测量结果M，srtt设置为M，rttvar设置为M/2`

#### **1.3 重传二义性问题**

`假如一个包被重传了一次后，收到了ack，这个ack是原始包的ack还是重传包的ack？`

解决办法有两个

* 一是当出现重传，收到重传信息的ack时，不能更新RTT估算值
* 二是使用TCP时间戳选项，一般使用方法二

解决方法一其实是`Karn算法`的一部分，Karn算法的完整解释如下： `当接收到重传信息的ack时，不进行该数据包的RTT测量，以此来避免重传二义性问题；对该数据包之后的RTO采取二进制退避策略，即RTO加倍，直到接收非重传数据，srtt才用于计算RTO`

### 2.快速重传

超时重传是一种效率很低的方式，因为RTO往往大于RTT的2倍，超时重传会导致网络利用率的降低，该算法的思想如下

* 当失序的报文段到达时，接收方应该立刻发出重复的ack，让发送端尽早得知有失序报文，当采用sack时，发送端可以获知有多个空缺
* 发送方有一个`重复ack阈值(dupthresh)`，来决定是否触发快速重传，通常为3，一些非标准方法（linux）会根据失序情况动态调整该值

### 3.伪重传问题与解法

**伪重传**：没有出现数据丢失的情况下，出现的重传。主要原因是伪超时（过早判定超时），其他情况如包失序、包重复、ack丢失也会造成伪重传

#### **3.1 伪超时**

<figure><img src="../../.gitbook/assets/image (12) (1).png" alt=""><figcaption></figcaption></figure>

#### **3.2 包失序**

<figure><img src="../../.gitbook/assets/image (13) (1).png" alt=""><figcaption></figcaption></figure>

* 当失序发生在反向(ack)链路，会使发送方窗口快速前移，造成流量突发，发送方对于不必要的ack丢弃
* 当失序发生在正向链路，接收方会无法识别失序和丢包，因为失序和丢包都会造成收到无序的包，当严重失序时，会触发快速重传，如上图所示

区分失序和丢包不是一个重要的问题，互联网中严重失序并不常见，反向链路失序不会导致重传，正向链路只有严重失序才会导致重传，而严重失序和丢包其实是非常相似的

#### **3.3 包重复**

接收方收到相同的包，是一定会返回ack的，因为接收方会认为ack丢了 有时候链路层会将一个包复制成多份，在接收方会返回多个相同的ack，从而触发快速重传。使用DSACK可以解决这个问题，`带有DSACK的ack会表明这个ack是由重复的包触发的，从而防止伪重传`

#### **3.4 ack丢包**

因为发送方是累积ack确认，如果一次性发送多个包，即使有ack丢弃，一般会被累计确认。除非ack大量丢包，导致发送方超时，才会导致伪重传

### 七.滑动窗口

### 1.零窗口

通告窗口表明接收方可接收的数据量，当窗口值为0时，可以有效阻止发送方发送，这时候即为`零窗口` 当接收端有可用空间时，会发送一个`窗口更新(window update)` **存在的问题** 如果包含窗口更新的ack丢失，会造成死锁，发送方等待窗口更新，接收方等待新数据。为了防止这种情况，发送方会有一个定时器，来发送`窗口探测(window probe)`

### 2.糊涂窗口(SWS)

当通告窗口较小时，发送端会立刻发送数据填满该窗口，从而在连接中形成了大量高耗费的小数据包。解决方法是发送方在通告窗口较小时避免发送小数据包，接收方避免发送小的窗口通告

### 八.拥塞控制

路由器因为无法处理高速率到达的流量而被迫丢弃数据信息的现象叫做`拥塞`，拥塞控制的难点在于`何时需要减缓tcp传输、如何减缓tcp传输、何时恢复tcp传输`

### 1.拥塞窗口

反映网络传输能力的变量称为`拥塞窗口(congestion window)`，即cwnd。发送端实际可用的窗口W是接收方通知窗口awnd和拥塞窗口cwnd的最小值

<figure><img src="../../.gitbook/assets/image (16) (1).png" alt=""><figcaption></figcaption></figure>

在tcp发送方的数据中，没有收到ack数据量不能超过W，这种已经发出但是没有确认的数据量大小称为`在外数据值(flight size)` W的值理论上最好的情况是等于`带宽延时积(BDP)`，过小会影响效率，过大会引入不必要的延时

### 2.拥塞原理

稳定状态下的tcp拥塞控制，实际是使网络传输路径下的`数据包守恒`，这是`数据包守恒原理` 发送方的拥塞控制是由ack来驱动的，由ack触发新的数据传输，叫做`自同步(self clocking)`，类似于负反馈，这叫做`ack时钟原理` 基于上述原理的拥塞算法叫做`慢启动和拥塞避免`

<figure><img src="../../.gitbook/assets/image (18) (1).png" alt=""><figcaption></figcaption></figure>

### 3.慢启动

<figure><img src="../../.gitbook/assets/image (19) (1).png" alt=""><figcaption></figcaption></figure>

RFC5681对慢启动描述如下，慢启动的触发条件有两个：`传输开始`和`重传计时器超时`&#x20;

<figure><img src="../../.gitbook/assets/image (20) (1).png" alt=""><figcaption></figcaption></figure>

慢启动是有阈值(ssthresh)的，该阈值是`tcp最优窗口估计值的下界`，ssthresh是会动态变化的，当出现重传情况时，无论是超时重传还是快速重传，ssthresh都会按照下面公式改变，该公式可能会使ssthresh增大，也可能使ssthresh减小

<figure><img src="../../.gitbook/assets/image (21) (1).png" alt=""><figcaption></figcaption></figure>

### 4.拥塞避免

拥塞避免是在慢启动之后的阶段，当慢启动快速增长到`慢启动阈值`，就会进入拥塞避免阶段，cwnd从指数增长变为线性增长 之所以设置一个阈值，是因为当慢启动如果不加限制增长，会占用全部的路由器资源，从而导致共享路由器的其他连接出现严重的丢包和重传，进而导致整个网络不稳定

<figure><img src="../../.gitbook/assets/image (22) (1).png" alt=""><figcaption></figcaption></figure>

### 5.经典的快速重传和快速恢复

参考TCP/IP对标准TCP的定义：

<figure><img src="../../.gitbook/assets/image (23) (1).png" alt=""><figcaption></figcaption></figure>

### 6.TCP NewReno

**经典快速恢复存在的问题** 当一个传输窗口存在多个丢包时，一旦一个数据包重传成功时，发送方就会收到一个好的ack，从而快速恢复阶段中cwnd窗口的暂时膨胀就会停止，而事实上丢失的其他数据包可能没有完成重传，这种情况被称为`局部ack`

**NewReno的解决办法** 该算法对快速恢复做出了改进，它记录了上一个传输窗口的最高序列号(恢复点)，只有当接收的序列号不小于恢复点的ack，才停止快速恢复

**NewReno的优点** TCP NewReno是现在比较常用的一个版本，避免了经典快速恢复的问题，实现起来也没有SACK复杂。使用SACK在多丢包的情况下可能会获得比NewReno更好的性能，但也意味着更复杂的拥塞控制

### 7.TCP CUBIC

CUBIC拥塞更适合高速网络(1Gbps)，并且可以兼顾rtt公平性

### 8.基于延迟的拥塞算法

* vegas
* FAST
* TCP WestWood
* 复合TCP

### 9.TCP拥塞相关的攻击

* ACK分割攻击，将原本一个ack切分成多个ack，使发送方cwnd快速增长。解决方法是计算ack确认的数据量来判断是否为真的ack
* 重复ack欺骗攻击，会使标准快速恢复模式中cwnd快速增长。解决方法是限制快速恢复的在外数据值
* 乐观响应攻击会对没有到达的报文产生ack，这会导致发送方rtt不准确。解决方法是定义一个可累加的随机数，使发送的数据段大小可随时间动态改变，来更好地匹配数据段和对应的ack

#### 注意事项

查看linux中tcp允许的拥塞控制算法，一般是cubic或者reno

```bash
# 不同linux发行版略有区别
cat /proc/sys/net/ipv4/tcp_allowed_congestion_control
```

### 九.连接管理

<figure><img src="../../.gitbook/assets/image (24) (1).png" alt=""><figcaption></figcaption></figure>
