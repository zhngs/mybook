# 索引

### 一.简介

索引可以加快查询数据的速度，但会使更新变慢，典型的空间换时间技术。

如果没有索引，每次查数据都会全表扫描，会有O(n)的时间复杂度，这在大表的场景下是不可接受的。

### 二.分类

#### 1.按照类型分类

* 主键索引：针对于表中主键创建的索引，默认自动创建, 只能有一个，使用PRIMARY关键字创建。
* 唯一索引：避免同一个表中某数据列中的值重复，可以有多个，使用UNIQUE关键字创建。
* 常规索引：快速定位特定数据，可以有多个。
* 全文索引：全文索引查找的是文本中的关键词，而不是比较索引中的值，可以有多个，使用关键字FULLTEXT创建。

#### 2.按照存储形式分类

* 聚集索引：将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据。聚集索引必须有，而且只有一个。
* 二级索引：将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键。可以存储多个。

聚集索引的选取规则如下：

* 如果存在主键，主键索引就是聚集索引。
* 如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。
* 如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。

通过二级索引查询数据的方式称为`回表查询`：

* 首先通过二级索引查找到主键值。
* 然后通过聚集索引根据主键值查找具体的数据。

### 三.索引语法

* 创建索引

```sql
CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name ( index_col_name,... );
```

* 查看索引

```sql
SHOW INDEX FROM table_name;
```

* 删除索引

```sql
DROP INDEX index_name ON table_name;
```

### 四.索引失效

#### 1.未遵守最左前缀法则

如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始， 并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。

注意：

* where后条件的顺序不影响最左前缀法则。

#### 2.范围查询

联合索引中，出现范围查询`(>,<)`，范围查询右侧的列索引失效。

所以，在业务允许的情况下，尽可能的使用类似于 >= 或 <= 这类的范围查询，而避免使用 > 或 <。

#### 3.在索引列上进行运算

在索引列上进行运算操作，索引将失效。

#### 4.字符串不加引号

字符串类型字段使用时，不加引号，索引将失效。

#### 5.模糊查询

如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。

#### 6.or连接条件

用or分割开的条件， 如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会 被用到。

#### 7.全表扫描更快

如果MySQL评估使用索引比全表更慢，则不使用索引。

因为索引是用来索引少量数据的，如果通过索引查询返回大批量的数据，则还不如走全表扫描来的快，此时索引就会失效。

注意：

* 判断索引字段is null或者is not null是受MySQL评估影响的，有可能走索引，也有可能不走索引。

### 五.特殊索引

#### 1.覆盖索引

覆盖索引是指查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到。这种索引可以避免回表查询。

#### 2.前缀索引

当字段类型为字符串（varchar，text，longtext等）时，有时候需要索引很长的字符串，这会让 索引变得很大。

可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。语法如下：

```sql
create index idx_xxx on table_name(column(n)) ;
```

#### 3.单列索引和联合索引

单列索引：一个索引只包含单个列。&#x20;

联合索引：一个索引包含了多个列。

### 六.索引设计原则

* 针对于数据量较大，且查询比较频繁的表建立索引。
* 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。
* 尽量选择区分度高（重复的值少）的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。
* 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。
* 尽量使用联合索引，减少单列索引。查询时，联合索引很多时候可以覆盖索引，节省存储空间， 避免回表，提高查询效率。
* 控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。
* 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含 NULL值时，它可以更好地确定哪个索引最有效地用于查询。
