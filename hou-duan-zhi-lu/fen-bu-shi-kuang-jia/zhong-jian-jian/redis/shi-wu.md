# 事务

### 一.简介

Redis 事务是一个单独的隔离操作，事务中的所有命令都会序列化、按顺序地执行。

Redis脚本通常比事务更简单更快，并且也是原子性的。

### 二.例子

MULTI开启事务，总是返回OK。

后续执行的命令都会进入队列，以QUEUED回复。

EXEC执行后，所有入队的命令被一起执行。执行顺序和入队顺序相同，返回值是列表，列表元素是入队单个命令的返回值。

DISCARD命令会刷新事务队列，并退出事务。

```
> MULTI
OK
> INCR foo
QUEUED
> INCR bar
QUEUED
> EXEC
1) (integer) 1
2) (integer) 1
```

组队阶段某个命令出现错误，执行时所有命令都会取消。

执行阶段某个命令错误，则只有报错的命令不会被执行，其他的命令都会执行，不会回滚。

### 三.命令

#### 1.MULTI

开启事务。

返回值：

* OK（simple string）

```
MULTI
```

#### 2.EXEC

```
EXEC
```

执行所有入队的命令。

RESP2返回值：

* 列表（array），列表元素是入队单个命令的返回值。
* 如果WATCH的key被改变，则返回Nil。

RESP3:

* 列表（array），列表元素是入队单个命令的返回值。
* 如果WATCH的key被改变，则返回Null。

#### 3.DISCARD

```
DISCARD
```

刷新事务队列，并退出事务，如果有WATCH的key，会将这些key取消watch。

返回值：

* OK（simple string）

#### 4.WATCH

```
WATCH key [key ...]
```

监视指定key，如果监视的key在WATCH和EXEC之间被更改，则事务会abort。

返回值：

* OK（simple string）

#### 5.UNWATCH

```
UNWATCH
```

取消之前所有WATCH的key。如果已经调用了EXEC或DISCARD，则不需要调用UNWATCH。

返回值：

* OK（simple string）

### 四.锁

#### 1.悲观锁

悲观锁(Pessimistic Lock)，每次拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等。

#### 2.乐观锁

乐观锁(Optimistic Lock)，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁适用于多读的应用类型，可以提高吞吐量。

redis可以使用WATCH来实现乐观锁，原理是WATCH一个key，在事务中对这个key进行操作，在EXEC对时候，如果key被更改，则事务失败，稍后重试即可。在大量写的时候可能会有很多失败。

### 五.秒杀案例

考虑一种场景：先查有没有存货，如果有则存货减一，表示秒杀成功。

#### 1.方案一

不加锁，使用redis先读后写，会出现超卖问题，即存货是负数，原因是读redis和写redis不是原子性的。

#### 2.方案二

使用redis乐观锁，这样可能会导致出现存货没抢光的情况，原因是乐观锁会导致很多请求失败。

#### 3.方案三

使用redis脚本，可以完美解决问题。
